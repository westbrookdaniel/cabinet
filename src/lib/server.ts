import { render } from '@/lib/render.ts';
import { serveDir } from 'std/http/file_server.ts';
import { ModuleMap } from '@/lib/types.ts';
import { bundleFiles } from './bundle.ts';

export const createServer = async (modules: ModuleMap) => {
    await generateModules();

    return async (req: Request): Promise<Response> => {
        if (req.method !== 'GET') {
            return new Response('Method not allowed', { status: 405 });
        }

        const url = new URL(req.url);

        if (url.pathname.startsWith('/public')) {
            return serveDir(req, { fsRoot: './src/public', urlRoot: 'public' });
        }

        if (url.pathname.startsWith('/bundle') && url.pathname.endsWith('.js')) {
            return serveBundle(url.pathname.replace('/bundle/', ''));
        }

        if (url.pathname === '/favicon.ico') {
            return new Response(null, { status: 404 });
        }

        const html = await render(modules, url);
        return new Response(new TextEncoder().encode(html));
    };
};

async function generateModules() {
    const importStr: string[] = [];
    const exportStr: string[] = [];
    for await (const dirEntry of Deno.readDir('./src/pages')) {
        if (!dirEntry.isFile) return;
        const name = dirEntry.name.replace('.tsx', '');
        importStr.push(`import _${name} from './src/pages/${name}.tsx';`);
        exportStr.push(`_${name}`);
    }

    const file = ` // This file is generated by src/lib/app.ts
${importStr.sort().join('\n')}

export const modules = {
    ${exportStr.sort().join(',\n    ')}
};
`;

    const currentFile = await Deno.readTextFile('./modules.gen.ts');
    const hasChanged = currentFile !== file;

    if (!hasChanged) return;

    try {
        await Deno.writeTextFile('./modules.gen.ts', file);
    } catch {
        console.log('Previous file: ' + file);
        console.log('Current file: ' + currentFile);
        throw new Error(
            'Runtime module generation is not supported on this platform. Please commit the generated file.',
        );
    }
}

// not sure if these even does anything on deno deploy
const cache = new Map<string, string>();

export async function serveBundle(path: string) {
    // use cache if we have it
    if (cache.has(path)) {
        return new Response(cache.get(path), { headers: { 'Content-Type': 'application/javascript' } });
    }

    // path is something like bundle/pages/index.js
    const pathToBundle = '../' + path;

    // find the original file extension
    let ext: string | null = null;
    for await (
        const dirEntry of Deno.readDir(
            new URL(pathToBundle.slice(0, pathToBundle.lastIndexOf('/')), import.meta.url).pathname,
        )
    ) {
        if (dirEntry.name.startsWith(pathToBundle.slice(pathToBundle.lastIndexOf('/') + 1, -3))) {
            ext = dirEntry.name.slice(dirEntry.name.lastIndexOf('.'));
            break;
        }
    }
    if (!ext) throw new Error('Could not find file extension for ' + pathToBundle);

    // bundle the file
    const outputs = await bundleFiles([
        pathToBundle.slice(0, -3) + ext,
    ]);

    // serve bundled file and cache output
    const text = outputs[0].text;
    cache.set(path, text);
    return new Response(text, { headers: { 'Content-Type': 'application/javascript' } });
}
