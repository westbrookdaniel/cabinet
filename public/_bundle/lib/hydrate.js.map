{
  "version": 3,
  "sources": ["../../../src/lib/history.ts", "../../../src/lib/router.ts", "../../../src/lib/hydrate.ts"],
  "sourcesContent": ["// Pretty similar to the history npm package and TanStack Router\n\nexport interface RouterHistory extends RouterLocation {\n    listen: (cb: () => void) => () => void;\n    // deno-lint-ignore no-explicit-any\n    push: (path: string, state?: any) => void;\n    // deno-lint-ignore no-explicit-any\n    replace: (path: string, state?: any) => void;\n    go: (index: number) => void;\n    back: () => void;\n    forward: () => void;\n    createHref: (href: string) => string;\n    block: (blockerFn: BlockerFn) => () => void;\n}\n\nexport interface RouterLocation {\n    href: string;\n    pathname: string;\n    search: string;\n    hash: string;\n    // deno-lint-ignore no-explicit-any\n    state: any;\n}\n\ntype BlockerFn = (retry: () => void, cancel: () => void) => void;\n\nconst popStateEvent = 'popstate';\nconst beforeUnloadEvent = 'beforeunload';\n\nconst beforeUnloadListener = (event: Event) => {\n    event.preventDefault();\n    // deno-lint-ignore ban-ts-comment\n    // @ts-ignore\n    return (event.returnValue = '');\n};\n\nconst stopBlocking = () => {\n    removeEventListener(beforeUnloadEvent, beforeUnloadListener, {\n        capture: true,\n    });\n};\n\nfunction createHistory(opts: {\n    getLocation: () => RouterLocation;\n    listener: (onUpdate: () => void) => () => void;\n    // deno-lint-ignore no-explicit-any\n    pushState: (path: string, state?: any) => void;\n    // deno-lint-ignore no-explicit-any\n    replaceState: (path: string, state?: any) => void;\n    go: (n: number) => void;\n    back: () => void;\n    forward: () => void;\n    createHref: (path: string) => string;\n}): RouterHistory {\n    let currentLocation = opts.getLocation();\n    let unsub = () => {};\n    // deno-lint-ignore prefer-const\n    let listeners = new Set<() => void>();\n    let blockers: BlockerFn[] = [];\n    // deno-lint-ignore prefer-const\n    let queue: (() => void)[] = [];\n\n    const tryFlush = () => {\n        if (blockers.length) {\n            blockers[0]?.(tryFlush, () => {\n                blockers = [];\n                stopBlocking();\n            });\n            return;\n        }\n\n        while (queue.length) {\n            queue.shift()?.();\n        }\n\n        onUpdate();\n    };\n\n    const queueTask = (task: () => void) => {\n        queue.push(task);\n        tryFlush();\n    };\n\n    const onUpdate = () => {\n        currentLocation = opts.getLocation();\n        listeners.forEach((listener) => listener());\n    };\n\n    return {\n        get hash() {\n            return currentLocation.hash;\n        },\n        get href() {\n            return currentLocation.href;\n        },\n        get pathname() {\n            return currentLocation.pathname;\n        },\n        get search() {\n            return currentLocation.search;\n        },\n        get state() {\n            return currentLocation.state;\n        },\n        listen: (cb: () => void) => {\n            if (listeners.size === 0) {\n                unsub = opts.listener(onUpdate);\n            }\n            listeners.add(cb);\n\n            return () => {\n                listeners.delete(cb);\n                if (listeners.size === 0) {\n                    unsub();\n                }\n            };\n        },\n        // deno-lint-ignore no-explicit-any\n        push: (path: string, state: any) => {\n            queueTask(() => {\n                opts.pushState(path, state);\n            });\n        },\n        // deno-lint-ignore no-explicit-any\n        replace: (path: string, state: any) => {\n            queueTask(() => {\n                opts.replaceState(path, state);\n            });\n        },\n        go: (index) => {\n            queueTask(() => {\n                opts.go(index);\n            });\n        },\n        back: () => {\n            queueTask(() => {\n                opts.back();\n            });\n        },\n        forward: () => {\n            queueTask(() => {\n                opts.forward();\n            });\n        },\n        createHref: (str) => opts.createHref(str),\n        block: (cb) => {\n            blockers.push(cb);\n\n            if (blockers.length === 1) {\n                addEventListener(beforeUnloadEvent, beforeUnloadListener, {\n                    capture: true,\n                });\n            }\n\n            return () => {\n                blockers = blockers.filter((b) => b !== cb);\n\n                if (!blockers.length) {\n                    stopBlocking();\n                }\n            };\n        },\n    };\n}\n\nexport function createBrowserHistory(): RouterHistory {\n    const getHref = () => `${window.location.pathname}${window.location.hash}${window.location.search}`;\n    const createHref = (path: string) => path;\n    const getLocation = () => parseLocation(getHref(), history.state);\n\n    return createHistory({\n        getLocation,\n        listener: (onUpdate) => {\n            addEventListener(popStateEvent, onUpdate);\n            return () => {\n                removeEventListener(popStateEvent, onUpdate);\n            };\n        },\n        pushState: (path, state) => {\n            window.history.pushState(\n                { ...state, key: getKey() },\n                '',\n                createHref(path),\n            );\n        },\n        replaceState: (path, state) => {\n            window.history.replaceState(\n                { ...state, key: getKey() },\n                '',\n                createHref(path),\n            );\n        },\n        back: () => window.history.back(),\n        forward: () => window.history.forward(),\n        go: (n) => window.history.go(n),\n        createHref: (path) => createHref(path),\n    });\n}\n\n// deno-lint-ignore no-explicit-any\nfunction parseLocation(href: string, state: any): RouterLocation {\n    const hashIndex = href.indexOf('#');\n    const searchIndex = href.indexOf('?');\n\n    return {\n        href,\n        pathname: href.substring(\n            0,\n            hashIndex > 0\n                ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex\n                : searchIndex > 0\n                ? searchIndex\n                : href.length,\n        ),\n        hash: hashIndex > -1 ? href.substring(hashIndex, searchIndex) : '',\n        search: searchIndex > -1 ? href.substring(searchIndex) : '',\n        state,\n    };\n}\n\nfunction getKey() {\n    // Using same implementation as getId\n    return Math.random().toString(36);\n}\n", "import { createBrowserHistory, RouterHistory } from '@/lib/history.ts';\nimport { renderNode } from '@/lib/render.ts';\nimport { PageType } from '@/lib/types.ts';\nimport { setMeta } from '@/lib/utils.tsx';\n\n/**\n * Setup client side routing\n */\nexport function createClientRouter(root: HTMLElement) {\n    const history = createBrowserHistory();\n\n    history.listen(async () => {\n        const path = history.pathname;\n        const bundlePath = `/_bundle/pages${path === '/' ? '/index' : path}.js`;\n        const page: PageType = (await import(bundlePath)).default;\n        renderNode(root, { type: page, attributes: {} });\n        if (page.meta) setMeta.from(page.meta);\n    });\n\n    // Hijack all links\n    document.querySelectorAll('a').forEach((el) => hijackLink(history, el));\n\n    // Watch for changes to the dom and hijack new or changed links\n    const observer = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n            switch (mutation.type) {\n                case 'childList':\n                    mutation.addedNodes.forEach((el) => {\n                        if (el instanceof HTMLElement) {\n                            if (el instanceof HTMLAnchorElement) hijackLink(history, el);\n                            el.querySelectorAll('a').forEach((el) => hijackLink(history, el));\n                        }\n                    });\n                    break;\n                case 'attributes': {\n                    const el = mutation.target;\n                    if (el instanceof HTMLElement) {\n                        if (el instanceof HTMLAnchorElement) hijackLink(history, el);\n                        el.querySelectorAll('a').forEach((el) => hijackLink(history, el));\n                    }\n                }\n            }\n        });\n    });\n\n    observer.observe(document, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n    });\n\n    return history;\n}\n\n/**\n * Map of elements to their event listeners\n * TODO: Add some manual cleanup for listeners when the element is removed?\n */\nconst existingRouterListeners = new WeakMap<HTMLElement, [string, EventListenerOrEventListenerObject]>();\n\nconst hijackLink = (history: RouterHistory, el: HTMLAnchorElement) => {\n    // Remove old listener\n    // We remove it here in case the target changes, or it changes to an external link\n    if (existingRouterListeners.has(el)) {\n        const [eventType, listener] = existingRouterListeners.get(el)!;\n        el.removeEventListener(eventType, listener);\n        // Remove from map\n        existingRouterListeners.delete(el);\n    }\n\n    // If same origin and internal\n    el.addEventListener('click', (e) => {\n        e.preventDefault();\n        const href = el.getAttribute('href')!;\n        if (!el.target && href?.startsWith('/')) {\n            history.push(href);\n        }\n    });\n};\n", "import { renderNode } from '@/lib/render.ts';\nimport { createClientRouter } from '@/lib/router.ts';\nimport type { PageType } from '@/lib/types.ts';\nimport { setMeta } from './utils.tsx';\n\n/**\n * Hydrates the dom elements with our component\n * Pretty much just a render but lets call it hydrate\n */\nexport default function hydrate(component: PageType) {\n    const root = document.getElementById('_root');\n    if (!root) throw new Error('Root element not found');\n    window.router = createClientRouter(root);\n    renderNode(root, { type: component, attributes: {} });\n    // This should already have been done during hydration\n    // Be we'll do it again just in case\n    if (component.meta) setMeta.from(component.meta);\n}\n"],
  "mappings": "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",
  "names": ["popStateEvent", "beforeUnloadEvent", "beforeUnloadListener", "event", "stopBlocking", "createHistory", "opts", "currentLocation", "unsub", "listeners", "blockers", "queue", "tryFlush", "onUpdate", "queueTask", "task", "listener", "cb", "path", "state", "index", "str", "b", "createBrowserHistory", "getHref", "createHref", "parseLocation", "getKey", "n", "href", "hashIndex", "searchIndex", "createClientRouter", "root", "history", "createBrowserHistory", "path", "page", "renderNode", "setMeta", "el", "hijackLink", "mutations", "mutation", "existingRouterListeners", "eventType", "listener", "e", "href", "hydrate", "component", "root", "createClientRouter", "renderNode", "setMeta"]
}
